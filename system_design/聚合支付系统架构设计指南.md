# 聚合支付系统架构设计指南

## 概述

聚合支付（四方支付模式）作为支付领域的重要创新，通过整合多种支付通道，为商户提供统一的支付接入服务。<mcreference link="https://mp.weixin.qq.com/s/fnOrZW87jFKSi5CeYzNMvA" index="0">0</mcreference> 本文将从技术架构、业务流程、清结算体系等维度，深入解析聚合支付系统的设计与实现。

## 一、聚合支付基础概念

### 1.1 定义与价值

<mcreference link="https://mp.weixin.qq.com/s/fnOrZW87jFKSi5CeYzNMvA" index="0">0</mcreference> 聚合支付是从事"支付、结算、清算"服务之外的"支付服务"，依托银行、非银机构等，利用自身技术与服务集成能力，将一个以上的银行、非银机构或清算组织的支付服务整合到一起，为商户提供统一服务的产品。

**核心价值：**
- **简化接入**：商户只需一次对接，即可拥有多种支付方式
- **统一管理**：提供统一的交易查询、对账、结算等功能
- **降低成本**：减少技术开发和运营成本
- **数据整合**：提供全面的经营分析和决策支持

### 1.2 市场驱动因素

<mcreference link="https://mp.weixin.qq.com/s/fnOrZW87jFKSi5CeYzNMvA" index="0">0</mcreference> 聚合支付出现的原因：

1. **支付方式多样化**：支付宝、微信支付、银联等多种支付方式增加了商户接入难度
2. **终端平台复杂**：安卓、iOS等多平台兼容性要求
3. **消费需求多元**：不同消费者的支付偏好和使用场景
4. **商户痛点**：收款方式单一、对账繁琐等问题
5. **场景优化**：主/被扫支付、NFC支付、H5支付等多场景需求

### 1.3 发展历程

<mcreference link="https://mp.weixin.qq.com/s/fnOrZW87jFKSi5CeYzNMvA" index="0">0</mcreference> 聚合支付发展经历三个阶段：

**第一阶段（2014-2015）：起步期**
- 线上支付市场饱和，支付机构转向线下
- 二维码成为线下支付主要媒介
- 聚合支付成为重要服务产品

**第二阶段（2016-2017）：爆发期**
- 产品快速迭代和推广
- 收单机构纷纷入局
- 支付宝和微信推动行业发展

**第三阶段（2017至今）：合规期**
- 监管政策陆续出台
- 严查"二清"行为
- 行业走向合规健康发展

## 二、系统架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                        聚合支付平台                          │
├─────────────────────────────────────────────────────────────┤
│  接入层    │  网关层    │  业务层    │  数据层    │  外部接口  │
├─────────────────────────────────────────────────────────────┤
│ • 商户接入  │ • API网关  │ • 支付服务  │ • 交易数据  │ • 支付宝   │
│ • 终端接入  │ • 路由分发  │ • 账务服务  │ • 账务数据  │ • 微信支付 │
│ • H5/小程序 │ • 协议转换  │ • 清结算   │ • 商户数据  │ • 银联     │
│ • APP接入  │ • 安全认证  │ • 风控服务  │ • 风控数据  │ • 银行通道 │
│ • 扫码支付  │ • 限流熔断  │ • 商户管理  │ • 日志数据  │ • 其他通道 │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 核心组件设计

#### 2.2.1 支付网关

```go
// 支付网关核心结构
type PaymentGateway struct {
    channelManager  *ChannelManager
    routingEngine   *RoutingEngine
    riskEngine      *RiskEngine
    accountingService *AccountingService
    notificationService *NotificationService
}

// 支付请求处理
func (gw *PaymentGateway) ProcessPayment(ctx context.Context, req *PaymentRequest) (*PaymentResponse, error) {
    // 1. 请求验证
    if err := gw.validateRequest(req); err != nil {
        return nil, fmt.Errorf("request validation failed: %w", err)
    }
    
    // 2. 商户验证
    merchant, err := gw.validateMerchant(ctx, req.MerchantID)
    if err != nil {
        return nil, fmt.Errorf("merchant validation failed: %w", err)
    }
    
    // 3. 风控检查
    riskResult, err := gw.riskEngine.Evaluate(ctx, req)
    if err != nil {
        return nil, fmt.Errorf("risk evaluation failed: %w", err)
    }
    
    if riskResult.Action == "REJECT" {
        return &PaymentResponse{
            Code:    "RISK_REJECT",
            Message: riskResult.Reason,
        }, nil
    }
    
    // 4. 通道路由
    channel, err := gw.routingEngine.SelectChannel(ctx, req, merchant)
    if err != nil {
        return nil, fmt.Errorf("channel selection failed: %w", err)
    }
    
    // 5. 创建交易记录
    transaction := &Transaction{
        ID:          generateTransactionID(),
        MerchantID:  req.MerchantID,
        OrderID:     req.OrderID,
        Amount:      req.Amount,
        Currency:    req.Currency,
        PayMethod:   req.PayMethod,
        ChannelID:   channel.ID,
        Status:      "PROCESSING",
        CreatedAt:   time.Now(),
    }
    
    if err := gw.accountingService.CreateTransaction(ctx, transaction); err != nil {
        return nil, fmt.Errorf("create transaction failed: %w", err)
    }
    
    // 6. 调用支付通道
    channelResp, err := gw.channelManager.Pay(ctx, channel, req)
    if err != nil {
        // 更新交易状态为失败
        gw.accountingService.UpdateTransactionStatus(ctx, transaction.ID, "FAILED")
        return nil, fmt.Errorf("channel payment failed: %w", err)
    }
    
    // 7. 更新交易状态
    transaction.Status = channelResp.Status
    transaction.ChannelOrderID = channelResp.ChannelOrderID
    gw.accountingService.UpdateTransaction(ctx, transaction)
    
    // 8. 构造响应
    response := &PaymentResponse{
        TransactionID: transaction.ID,
        Status:        channelResp.Status,
        PayURL:        channelResp.PayURL,
        QRCode:        channelResp.QRCode,
    }
    
    return response, nil
}
```

#### 2.2.2 通道管理器

```go
// 支付通道接口
type PaymentChannel interface {
    GetChannelInfo() *ChannelInfo
    Pay(ctx context.Context, req *ChannelPayRequest) (*ChannelPayResponse, error)
    Query(ctx context.Context, req *ChannelQueryRequest) (*ChannelQueryResponse, error)
    Refund(ctx context.Context, req *ChannelRefundRequest) (*ChannelRefundResponse, error)
    Close(ctx context.Context, req *ChannelCloseRequest) (*ChannelCloseResponse, error)
}

// 通道管理器
type ChannelManager struct {
    channels    map[string]PaymentChannel
    config      *ChannelConfig
    healthCheck *HealthChecker
    metrics     *ChannelMetrics
}

// 支付宝通道实现
type AlipayChannel struct {
    appID      string
    privateKey string
    publicKey  string
    gateway    string
    client     *http.Client
}

func (c *AlipayChannel) Pay(ctx context.Context, req *ChannelPayRequest) (*ChannelPayResponse, error) {
    // 构造支付宝请求参数
    params := map[string]string{
        "app_id":      c.appID,
        "method":      "alipay.trade.create",
        "charset":     "utf-8",
        "sign_type":   "RSA2",
        "timestamp":   time.Now().Format("2006-01-02 15:04:05"),
        "version":     "1.0",
        "notify_url":  req.NotifyURL,
        "biz_content": c.buildBizContent(req),
    }
    
    // 签名
    sign, err := c.sign(params)
    if err != nil {
        return nil, fmt.Errorf("sign failed: %w", err)
    }
    params["sign"] = sign
    
    // 发送请求
    resp, err := c.sendRequest(ctx, params)
    if err != nil {
        return nil, fmt.Errorf("send request failed: %w", err)
    }
    
    // 解析响应
    return c.parseResponse(resp)
}

// 微信支付通道实现
type WechatChannel struct {
    appID     string
    mchID     string
    apiKey    string
    certPath  string
    keyPath   string
    client    *http.Client
}

func (c *WechatChannel) Pay(ctx context.Context, req *ChannelPayRequest) (*ChannelPayResponse, error) {
    // 构造微信支付请求
    params := map[string]string{
        "appid":            c.appID,
        "mch_id":           c.mchID,
        "nonce_str":        generateNonce(),
        "body":             req.Subject,
        "out_trade_no":     req.OrderID,
        "total_fee":        fmt.Sprintf("%.0f", req.Amount*100), // 转换为分
        "spbill_create_ip": req.ClientIP,
        "notify_url":       req.NotifyURL,
        "trade_type":       req.TradeType,
    }
    
    // 签名
    sign := c.sign(params)
    params["sign"] = sign
    
    // 构造XML请求
    xmlData := c.buildXML(params)
    
    // 发送请求
    resp, err := c.client.Post("https://api.mch.weixin.qq.com/pay/unifiedorder", "application/xml", strings.NewReader(xmlData))
    if err != nil {
        return nil, fmt.Errorf("send request failed: %w", err)
    }
    defer resp.Body.Close()
    
    // 解析响应
    return c.parseXMLResponse(resp.Body)
}
```

#### 2.2.3 路由引擎

```go
// 路由引擎
type RoutingEngine struct {
    rules       []RoutingRule
    channelPool *ChannelPool
    metrics     *RoutingMetrics
}

type RoutingRule struct {
    Priority    int                    `json:"priority"`
    Conditions  []RoutingCondition     `json:"conditions"`
    Actions     []RoutingAction        `json:"actions"`
    Enabled     bool                   `json:"enabled"`
}

type RoutingCondition struct {
    Field    string      `json:"field"`     // amount, pay_method, merchant_id等
    Operator string      `json:"operator"`  // eq, gt, lt, in等
    Value    interface{} `json:"value"`
}

type RoutingAction struct {
    Type      string                 `json:"type"`       // select_channel, set_weight等
    Params    map[string]interface{} `json:"params"`
}

func (re *RoutingEngine) SelectChannel(ctx context.Context, req *PaymentRequest, merchant *Merchant) (*Channel, error) {
    // 获取可用通道列表
    availableChannels := re.getAvailableChannels(req.PayMethod)
    if len(availableChannels) == 0 {
        return nil, fmt.Errorf("no available channels for pay method: %s", req.PayMethod)
    }
    
    // 应用路由规则
    for _, rule := range re.rules {
        if !rule.Enabled {
            continue
        }
        
        // 检查条件是否匹配
        if re.matchConditions(rule.Conditions, req, merchant) {
            // 执行路由动作
            channel, err := re.executeActions(rule.Actions, availableChannels, req)
            if err != nil {
                log.Errorf("Execute routing action failed: %v", err)
                continue
            }
            
            if channel != nil {
                re.metrics.RecordRouting(rule.Priority, channel.ID)
                return channel, nil
            }
        }
    }
    
    // 默认路由策略：负载均衡
    return re.loadBalanceSelect(availableChannels), nil
}

func (re *RoutingEngine) matchConditions(conditions []RoutingCondition, req *PaymentRequest, merchant *Merchant) bool {
    for _, condition := range conditions {
        if !re.evaluateCondition(condition, req, merchant) {
            return false
        }
    }
    return true
}

func (re *RoutingEngine) evaluateCondition(condition RoutingCondition, req *PaymentRequest, merchant *Merchant) bool {
    var fieldValue interface{}
    
    switch condition.Field {
    case "amount":
        fieldValue = req.Amount
    case "pay_method":
        fieldValue = req.PayMethod
    case "merchant_id":
        fieldValue = req.MerchantID
    case "merchant_type":
        fieldValue = merchant.Type
    case "time_hour":
        fieldValue = time.Now().Hour()
    default:
        return false
    }
    
    switch condition.Operator {
    case "eq":
        return fieldValue == condition.Value
    case "gt":
        if fv, ok := fieldValue.(float64); ok {
            if cv, ok := condition.Value.(float64); ok {
                return fv > cv
            }
        }
    case "lt":
        if fv, ok := fieldValue.(float64); ok {
            if cv, ok := condition.Value.(float64); ok {
                return fv < cv
            }
        }
    case "in":
        if values, ok := condition.Value.([]interface{}); ok {
            for _, v := range values {
                if fieldValue == v {
                    return true
                }
            }
        }
    }
    
    return false
}

// 负载均衡选择通道
func (re *RoutingEngine) loadBalanceSelect(channels []*Channel) *Channel {
    if len(channels) == 0 {
        return nil
    }
    
    // 加权轮询算法
    totalWeight := 0
    for _, channel := range channels {
        totalWeight += channel.Weight
    }
    
    if totalWeight == 0 {
        // 如果没有权重，随机选择
        return channels[rand.Intn(len(channels))]
    }
    
    randomWeight := rand.Intn(totalWeight)
    currentWeight := 0
    
    for _, channel := range channels {
        currentWeight += channel.Weight
        if randomWeight < currentWeight {
            return channel
        }
    }
    
    return channels[0]
}
```

### 2.3 账务系统设计

#### 2.3.1 账务核心模型

```go
// 账务实体
type Account struct {
    ID            string          `json:"id"`
    MerchantID    string          `json:"merchant_id"`
    AccountType   AccountType     `json:"account_type"`   // 可用余额、冻结余额、待结算
    Currency      string          `json:"currency"`
    Balance       decimal.Decimal `json:"balance"`
    FrozenAmount  decimal.Decimal `json:"frozen_amount"`
    Version       int64           `json:"version"`        // 乐观锁版本号
    CreatedAt     time.Time       `json:"created_at"`
    UpdatedAt     time.Time       `json:"updated_at"`
}

type AccountType string

const (
    AccountTypeAvailable    AccountType = "AVAILABLE"    // 可用余额
    AccountTypeFrozen       AccountType = "FROZEN"       // 冻结余额
    AccountTypePendingSettle AccountType = "PENDING_SETTLE" // 待结算
)

// 账务流水
type AccountingEntry struct {
    ID            string          `json:"id"`
    TransactionID string          `json:"transaction_id"`
    AccountID     string          `json:"account_id"`
    EntryType     EntryType       `json:"entry_type"`     // 借记、贷记
    Amount        decimal.Decimal `json:"amount"`
    Balance       decimal.Decimal `json:"balance"`        // 操作后余额
    Description   string          `json:"description"`
    CreatedAt     time.Time       `json:"created_at"`
}

type EntryType string

const (
    EntryTypeDebit  EntryType = "DEBIT"   // 借记（减少）
    EntryTypeCredit EntryType = "CREDIT"  // 贷记（增加）
)

// 账务服务
type AccountingService struct {
    db          database.Client
    lockManager *DistributedLock
    eventBus    *EventBus
}

// 账务处理（支付成功）
func (s *AccountingService) ProcessPaymentSuccess(ctx context.Context, transaction *Transaction) error {
    return s.db.Transaction(ctx, func(tx database.Tx) error {
        // 1. 获取商户账户（加锁）
        lockKey := fmt.Sprintf("account_lock:%s", transaction.MerchantID)
        lock, err := s.lockManager.Acquire(ctx, lockKey, 30*time.Second)
        if err != nil {
            return fmt.Errorf("acquire lock failed: %w", err)
        }
        defer lock.Release()
        
        // 2. 查询商户待结算账户
        account, err := s.getAccountByType(ctx, tx, transaction.MerchantID, AccountTypePendingSettle)
        if err != nil {
            return fmt.Errorf("get account failed: %w", err)
        }
        
        // 3. 计算手续费
        fee := s.calculateFee(transaction)
        netAmount := transaction.Amount.Sub(fee)
        
        // 4. 更新账户余额（乐观锁）
        newBalance := account.Balance.Add(netAmount)
        affected, err := tx.Exec(`
            UPDATE accounts 
            SET balance = ?, version = version + 1, updated_at = ?
            WHERE id = ? AND version = ?
        `, newBalance, time.Now(), account.ID, account.Version)
        
        if err != nil {
            return fmt.Errorf("update account failed: %w", err)
        }
        
        if affected == 0 {
            return fmt.Errorf("account version conflict")
        }
        
        // 5. 记录账务流水
        entry := &AccountingEntry{
            ID:            generateEntryID(),
            TransactionID: transaction.ID,
            AccountID:     account.ID,
            EntryType:     EntryTypeCredit,
            Amount:        netAmount,
            Balance:       newBalance,
            Description:   fmt.Sprintf("Payment success: %s", transaction.ID),
            CreatedAt:     time.Now(),
        }
        
        if err := s.createAccountingEntry(ctx, tx, entry); err != nil {
            return fmt.Errorf("create accounting entry failed: %w", err)
        }
        
        // 6. 如果有手续费，记录手续费流水
        if fee.GreaterThan(decimal.Zero) {
            feeEntry := &AccountingEntry{
                ID:            generateEntryID(),
                TransactionID: transaction.ID,
                AccountID:     account.ID,
                EntryType:     EntryTypeDebit,
                Amount:        fee,
                Balance:       newBalance,
                Description:   fmt.Sprintf("Transaction fee: %s", transaction.ID),
                CreatedAt:     time.Now(),
            }
            
            if err := s.createAccountingEntry(ctx, tx, feeEntry); err != nil {
                return fmt.Errorf("create fee entry failed: %w", err)
            }
        }
        
        // 7. 发送账务事件
        event := &AccountingEvent{
            Type:          "PAYMENT_SUCCESS",
            TransactionID: transaction.ID,
            MerchantID:    transaction.MerchantID,
            Amount:        netAmount,
            Fee:           fee,
            Timestamp:     time.Now(),
        }
        
        return s.eventBus.Publish(ctx, "accounting.payment_success", event)
    })
}

// 手续费计算
func (s *AccountingService) calculateFee(transaction *Transaction) decimal.Decimal {
    // 根据商户费率配置计算手续费
    merchant, err := s.getMerchant(transaction.MerchantID)
    if err != nil {
        log.Errorf("Get merchant failed: %v", err)
        return decimal.Zero
    }
    
    var feeRate decimal.Decimal
    switch transaction.PayMethod {
    case "ALIPAY":
        feeRate = merchant.AlipayFeeRate
    case "WECHAT":
        feeRate = merchant.WechatFeeRate
    case "UNIONPAY":
        feeRate = merchant.UnionpayFeeRate
    default:
        feeRate = merchant.DefaultFeeRate
    }
    
    fee := transaction.Amount.Mul(feeRate)
    
    // 最小手续费限制
    if fee.LessThan(merchant.MinFee) {
        fee = merchant.MinFee
    }
    
    // 最大手续费限制
    if fee.GreaterThan(merchant.MaxFee) {
        fee = merchant.MaxFee
    }
    
    return fee
}
```

#### 2.3.2 清结算系统

```go
// 清结算服务
type SettlementService struct {
    accountingService *AccountingService
    bankService       *BankService
    scheduler         *SettlementScheduler
    db               database.Client
}

// 结算任务
type SettlementTask struct {
    ID           string          `json:"id"`
    MerchantID   string          `json:"merchant_id"`
    Amount       decimal.Decimal `json:"amount"`
    Currency     string          `json:"currency"`
    BankAccount  string          `json:"bank_account"`
    Status       SettlementStatus `json:"status"`
    ScheduledAt  time.Time       `json:"scheduled_at"`
    ExecutedAt   *time.Time      `json:"executed_at"`
    CompletedAt  *time.Time      `json:"completed_at"`
    FailureReason string         `json:"failure_reason"`
    CreatedAt    time.Time       `json:"created_at"`
}

type SettlementStatus string

const (
    SettlementStatusPending    SettlementStatus = "PENDING"
    SettlementStatusProcessing SettlementStatus = "PROCESSING"
    SettlementStatusSuccess    SettlementStatus = "SUCCESS"
    SettlementStatusFailed     SettlementStatus = "FAILED"
)

// 自动结算调度器
func (s *SettlementService) StartScheduler(ctx context.Context) {
    ticker := time.NewTicker(1 * time.Hour) // 每小时检查一次
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            if err := s.processScheduledSettlements(ctx); err != nil {
                log.Errorf("Process scheduled settlements failed: %v", err)
            }
        }
    }
}

func (s *SettlementService) processScheduledSettlements(ctx context.Context) error {
    // 查询需要结算的商户
    merchants, err := s.getMerchantsForSettlement(ctx)
    if err != nil {
        return fmt.Errorf("get merchants for settlement failed: %w", err)
    }
    
    for _, merchant := range merchants {
        if err := s.processMerchantSettlement(ctx, merchant); err != nil {
            log.Errorf("Process merchant settlement failed for %s: %v", merchant.ID, err)
        }
    }
    
    return nil
}

func (s *SettlementService) processMerchantSettlement(ctx context.Context, merchant *Merchant) error {
    // 1. 检查结算条件
    if !s.shouldSettle(merchant) {
        return nil
    }
    
    // 2. 计算可结算金额
    settlementAmount, err := s.calculateSettlementAmount(ctx, merchant.ID)
    if err != nil {
        return fmt.Errorf("calculate settlement amount failed: %w", err)
    }
    
    if settlementAmount.LessThanOrEqual(decimal.Zero) {
        return nil // 没有可结算金额
    }
    
    // 3. 检查最小结算金额
    if settlementAmount.LessThan(merchant.MinSettlementAmount) {
        return nil
    }
    
    // 4. 创建结算任务
    task := &SettlementTask{
        ID:          generateSettlementID(),
        MerchantID:  merchant.ID,
        Amount:      settlementAmount,
        Currency:    "CNY",
        BankAccount: merchant.BankAccount,
        Status:      SettlementStatusPending,
        ScheduledAt: time.Now(),
        CreatedAt:   time.Now(),
    }
    
    if err := s.createSettlementTask(ctx, task); err != nil {
        return fmt.Errorf("create settlement task failed: %w", err)
    }
    
    // 5. 执行结算
    return s.executeSettlement(ctx, task)
}

func (s *SettlementService) executeSettlement(ctx context.Context, task *SettlementTask) error {
    // 1. 更新任务状态为处理中
    if err := s.updateSettlementStatus(ctx, task.ID, SettlementStatusProcessing); err != nil {
        return fmt.Errorf("update settlement status failed: %w", err)
    }
    
    // 2. 账务处理：从待结算账户转移到银行账户
    if err := s.transferToBank(ctx, task); err != nil {
        s.updateSettlementStatus(ctx, task.ID, SettlementStatusFailed)
        return fmt.Errorf("transfer to bank failed: %w", err)
    }
    
    // 3. 调用银行接口进行转账
    bankResp, err := s.bankService.Transfer(ctx, &BankTransferRequest{
        FromAccount: s.getPlatformAccount(),
        ToAccount:   task.BankAccount,
        Amount:      task.Amount,
        Currency:    task.Currency,
        Reference:   task.ID,
    })
    
    if err != nil {
        // 银行转账失败，回滚账务
        s.rollbackTransfer(ctx, task)
        s.updateSettlementStatus(ctx, task.ID, SettlementStatusFailed)
        return fmt.Errorf("bank transfer failed: %w", err)
    }
    
    // 4. 更新任务状态
    now := time.Now()
    task.Status = SettlementStatusSuccess
    task.CompletedAt = &now
    
    if err := s.updateSettlementTask(ctx, task); err != nil {
        log.Errorf("Update settlement task failed: %v", err)
    }
    
    // 5. 发送结算通知
    s.sendSettlementNotification(ctx, task, bankResp)
    
    return nil
}

// 结算条件检查
func (s *SettlementService) shouldSettle(merchant *Merchant) bool {
    now := time.Now()
    
    switch merchant.SettlementCycle {
    case "DAILY":
        // 每日结算：检查是否到了结算时间
        settlementTime := time.Date(now.Year(), now.Month(), now.Day(), 
            merchant.SettlementHour, merchant.SettlementMinute, 0, 0, now.Location())
        return now.After(settlementTime) && now.Before(settlementTime.Add(time.Hour))
        
    case "WEEKLY":
        // 每周结算：检查是否是结算日
        return now.Weekday() == merchant.SettlementWeekday
        
    case "MONTHLY":
        // 每月结算：检查是否是结算日
        return now.Day() == merchant.SettlementDay
        
    default:
        return false
    }
}
```

## 三、风控系统设计

### 3.1 风控引擎架构

```go
// 风控引擎
type RiskEngine struct {
    ruleEngine    *RuleEngine
    modelEngine   *ModelEngine
    blacklistService *BlacklistService
    deviceService *DeviceService
    geoService    *GeoService
}

// 风控评估
func (re *RiskEngine) Evaluate(ctx context.Context, req *PaymentRequest) (*RiskResult, error) {
    // 1. 基础信息提取
    riskContext := &RiskContext{
        TransactionID: generateTransactionID(),
        MerchantID:    req.MerchantID,
        Amount:        req.Amount,
        PayMethod:     req.PayMethod,
        ClientIP:      req.ClientIP,
        UserAgent:     req.UserAgent,
        DeviceID:      req.DeviceID,
        Timestamp:     time.Now(),
    }
    
    // 2. 特征工程
    features, err := re.extractFeatures(ctx, riskContext)
    if err != nil {
        return nil, fmt.Errorf("extract features failed: %w", err)
    }
    
    // 3. 规则引擎评估
    ruleResult, err := re.ruleEngine.Evaluate(ctx, features)
    if err != nil {
        return nil, fmt.Errorf("rule evaluation failed: %w", err)
    }
    
    // 4. 机器学习模型评估
    modelResult, err := re.modelEngine.Predict(ctx, features)
    if err != nil {
        log.Errorf("Model prediction failed: %v", err)
        // 模型失败不影响规则引擎结果
        modelResult = &ModelResult{Score: 0.0}
    }
    
    // 5. 综合决策
    finalResult := re.makeFinalDecision(ruleResult, modelResult)
    
    // 6. 记录风控日志
    re.logRiskEvaluation(ctx, riskContext, features, ruleResult, modelResult, finalResult)
    
    return finalResult, nil
}

// 特征提取
func (re *RiskEngine) extractFeatures(ctx context.Context, riskCtx *RiskContext) (*RiskFeatures, error) {
    features := &RiskFeatures{
        BasicFeatures:    re.extractBasicFeatures(riskCtx),
        BehaviorFeatures: make(map[string]float64),
        DeviceFeatures:   make(map[string]string),
        GeoFeatures:      make(map[string]string),
    }
    
    // 并发提取各类特征
    var wg sync.WaitGroup
    
    // 行为特征
    wg.Add(1)
    go func() {
        defer wg.Done()
        behaviorFeatures, err := re.extractBehaviorFeatures(ctx, riskCtx)
        if err != nil {
            log.Errorf("Extract behavior features failed: %v", err)
            return
        }
        features.BehaviorFeatures = behaviorFeatures
    }()
    
    // 设备特征
    wg.Add(1)
    go func() {
        defer wg.Done()
        deviceFeatures, err := re.extractDeviceFeatures(ctx, riskCtx)
        if err != nil {
            log.Errorf("Extract device features failed: %v", err)
            return
        }
        features.DeviceFeatures = deviceFeatures
    }()
    
    // 地理位置特征
    wg.Add(1)
    go func() {
        defer wg.Done()
        geoFeatures, err := re.extractGeoFeatures(ctx, riskCtx)
        if err != nil {
            log.Errorf("Extract geo features failed: %v", err)
            return
        }
        features.GeoFeatures = geoFeatures
    }()
    
    wg.Wait()
    
    return features, nil
}

// 行为特征提取
func (re *RiskEngine) extractBehaviorFeatures(ctx context.Context, riskCtx *RiskContext) (map[string]float64, error) {
    features := make(map[string]float64)
    
    // 1. 商户历史交易统计
    merchantStats, err := re.getMerchantTransactionStats(ctx, riskCtx.MerchantID, 24*time.Hour)
    if err != nil {
        return nil, err
    }
    
    features["merchant_txn_count_24h"] = float64(merchantStats.Count)
    features["merchant_txn_amount_24h"] = merchantStats.TotalAmount
    features["merchant_avg_amount_24h"] = merchantStats.AvgAmount
    
    // 2. IP地址历史行为
    ipStats, err := re.getIPTransactionStats(ctx, riskCtx.ClientIP, time.Hour)
    if err != nil {
        return nil, err
    }
    
    features["ip_txn_count_1h"] = float64(ipStats.Count)
    features["ip_merchant_count_1h"] = float64(ipStats.UniqueMerchants)
    
    // 3. 设备历史行为
    if riskCtx.DeviceID != "" {
        deviceStats, err := re.getDeviceTransactionStats(ctx, riskCtx.DeviceID, 24*time.Hour)
        if err != nil {
            return nil, err
        }
        
        features["device_txn_count_24h"] = float64(deviceStats.Count)
        features["device_merchant_count_24h"] = float64(deviceStats.UniqueMerchants)
    }
    
    // 4. 金额相关特征
    features["amount"] = riskCtx.Amount
    features["amount_percentile"] = re.calculateAmountPercentile(riskCtx.Amount, merchantStats.AmountDistribution)
    
    // 5. 时间特征
    hour := float64(riskCtx.Timestamp.Hour())
    features["hour_of_day"] = hour
    features["is_weekend"] = re.boolToFloat(riskCtx.Timestamp.Weekday() == time.Saturday || riskCtx.Timestamp.Weekday() == time.Sunday)
    
    return features, nil
}

// 规则引擎
type RuleEngine struct {
    rules []RiskRule
}

type RiskRule struct {
    ID          string           `json:"id"`
    Name        string           `json:"name"`
    Priority    int              `json:"priority"`
    Conditions  []RiskCondition  `json:"conditions"`
    Action      RiskAction       `json:"action"`
    Enabled     bool             `json:"enabled"`
}

type RiskCondition struct {
    Feature   string      `json:"feature"`
    Operator  string      `json:"operator"`  // gt, lt, eq, in等
    Value     interface{} `json:"value"`
    Weight    float64     `json:"weight"`
}

type RiskAction struct {
    Type   string  `json:"type"`    // PASS, REJECT, REVIEW
    Score  float64 `json:"score"`   // 风险分数
    Reason string  `json:"reason"`  // 触发原因
}

func (re *RuleEngine) Evaluate(ctx context.Context, features *RiskFeatures) (*RuleResult, error) {
    result := &RuleResult{
        Action:        "PASS",
        Score:         0.0,
        TriggeredRules: []string{},
    }
    
    // 按优先级排序规则
    sort.Slice(re.rules, func(i, j int) bool {
        return re.rules[i].Priority < re.rules[j].Priority
    })
    
    for _, rule := range re.rules {
        if !rule.Enabled {
            continue
        }
        
        // 评估规则条件
        if re.evaluateRule(rule, features) {
            result.TriggeredRules = append(result.TriggeredRules, rule.ID)
            result.Score += rule.Action.Score
            
            // 如果是拒绝规则，直接返回
            if rule.Action.Type == "REJECT" {
                result.Action = "REJECT"
                result.Reason = rule.Action.Reason
                return result, nil
            }
            
            // 如果是审核规则，标记为审核
            if rule.Action.Type == "REVIEW" {
                result.Action = "REVIEW"
                result.Reason = rule.Action.Reason
            }
        }
    }
    
    return result, nil
}

// 黑名单服务
type BlacklistService struct {
    cache redis.Client
    db    database.Client
}

func (bs *BlacklistService) IsBlacklisted(ctx context.Context, listType, value string) (bool, error) {
    // 1. 先查缓存
    cacheKey := fmt.Sprintf("blacklist:%s:%s", listType, value)
    cached, err := bs.cache.Get(ctx, cacheKey).Result()
    if err == nil {
        return cached == "1", nil
    }
    
    // 2. 查数据库
    var count int
    err = bs.db.QueryRow(ctx, `
        SELECT COUNT(*) FROM blacklist 
        WHERE list_type = ? AND value = ? AND status = 'ACTIVE'
    `, listType, value).Scan(&count)
    
    if err != nil {
        return false, fmt.Errorf("query blacklist failed: %w", err)
    }
    
    isBlacklisted := count > 0
    
    // 3. 写入缓存
    cacheValue := "0"
    if isBlacklisted {
        cacheValue = "1"
    }
    bs.cache.Set(ctx, cacheKey, cacheValue, 5*time.Minute)
    
    return isBlacklisted, nil
}
```

## 四、监控与运维

### 4.1 监控体系

```yaml
# Prometheus监控配置
monitoring:
  metrics:
    # 业务指标
    business:
      - name: payment_requests_total
        type: counter
        labels: [merchant_id, pay_method, status]
        description: "Total payment requests"
      
      - name: payment_amount_total
        type: counter
        labels: [merchant_id, pay_method, currency]
        description: "Total payment amount"
      
      - name: payment_duration_seconds
        type: histogram
        labels: [merchant_id, pay_method, channel]
        buckets: [0.1, 0.5, 1, 2, 5, 10]
        description: "Payment processing duration"
    
    # 系统指标
    system:
      - name: channel_requests_total
        type: counter
        labels: [channel, status]
        description: "Total channel requests"
      
      - name: channel_response_time_seconds
        type: histogram
        labels: [channel]
        buckets: [0.1, 0.5, 1, 2, 5]
        description: "Channel response time"
      
      - name: risk_evaluations_total
        type: counter
        labels: [action, reason]
        description: "Total risk evaluations"

  alerts:
    # 支付成功率告警
    - name: PaymentSuccessRateLow
      expr: |
        (
          sum(rate(payment_requests_total{status="SUCCESS"}[5m])) /
          sum(rate(payment_requests_total[5m]))
        ) < 0.95
      for: 2m
      severity: critical
      message: "Payment success rate is below 95%"
    
    # 支付响应时间告警
    - name: PaymentResponseTimeHigh
      expr: |
        histogram_quantile(0.95, 
          sum(rate(payment_duration_seconds_bucket[5m])) by (le)
        ) > 5
      for: 3m
      severity: warning
      message: "95th percentile payment response time is above 5 seconds"
    
    # 通道异常告警
    - name: ChannelErrorRateHigh
      expr: |
        (
          sum(rate(channel_requests_total{status!="SUCCESS"}[5m])) by (channel) /
          sum(rate(channel_requests_total[5m])) by (channel)
        ) > 0.1
      for: 1m
      severity: critical
      message: "Channel {{ $labels.channel }} error rate is above 10%"
```

### 4.2 日志系统

```go
// 结构化日志
type PaymentLogger struct {
    logger *logrus.Logger
    fields logrus.Fields
}

func (pl *PaymentLogger) LogPaymentRequest(req *PaymentRequest) {
    pl.logger.WithFields(logrus.Fields{
        "event_type":    "payment_request",
        "transaction_id": req.TransactionID,
        "merchant_id":   req.MerchantID,
        "order_id":      req.OrderID,
        "amount":        req.Amount,
        "currency":      req.Currency,
        "pay_method":    req.PayMethod,
        "client_ip":     req.ClientIP,
        "user_agent":    req.UserAgent,
        "timestamp":     time.Now().Unix(),
    }).Info("Payment request received")
}

func (pl *PaymentLogger) LogPaymentResult(transactionID string, result *PaymentResponse) {
    pl.logger.WithFields(logrus.Fields{
        "event_type":     "payment_result",
        "transaction_id":  transactionID,
        "status":         result.Status,
        "channel_order_id": result.ChannelOrderID,
        "processing_time": result.ProcessingTime,
        "timestamp":      time.Now().Unix(),
    }).Info("Payment processing completed")
}

func (pl *PaymentLogger) LogRiskEvaluation(transactionID string, riskResult *RiskResult) {
    pl.logger.WithFields(logrus.Fields{
        "event_type":      "risk_evaluation",
        "transaction_id":   transactionID,
        "risk_action":      riskResult.Action,
        "risk_score":       riskResult.Score,
        "triggered_rules":  riskResult.TriggeredRules,
        "reason":          riskResult.Reason,
        "timestamp":       time.Now().Unix(),
    }).Info("Risk evaluation completed")
}
```

## 五、部署与扩展

### 5.1 微服务部署

```yaml
# docker-compose.yml
version: '3.8'

services:
  # API网关
  api-gateway:
    image: payment-gateway:latest
    ports:
      - "8080:8080"
    environment:
      - REDIS_URL=redis://redis:6379
      - DB_URL=mysql://user:pass@mysql:3306/payment
    depends_on:
      - redis
      - mysql
    deploy:
      replicas: 3
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
  
  # 支付服务
  payment-service:
    image: payment-service:latest
    environment:
      - REDIS_URL=redis://redis:6379
      - DB_URL=mysql://user:pass@mysql:3306/payment
      - KAFKA_BROKERS=kafka:9092
    depends_on:
      - redis
      - mysql
      - kafka
    deploy:
      replicas: 5
      resources:
        limits:
          memory: 1G
          cpus: '1'
  
  # 账务服务
  accounting-service:
    image: accounting-service:latest
    environment:
      - DB_URL=mysql://user:pass@mysql:3306/accounting
      - KAFKA_BROKERS=kafka:9092
    depends_on:
      - mysql
      - kafka
    deploy:
      replicas: 3
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
  
  # 风控服务
  risk-service:
    image: risk-service:latest
    environment:
      - REDIS_URL=redis://redis:6379
      - DB_URL=mysql://user:pass@mysql:3306/risk
      - ML_MODEL_URL=http://ml-service:8080
    depends_on:
      - redis
      - mysql
    deploy:
      replicas: 2
      resources:
        limits:
          memory: 1G
          cpus: '1'
  
  # 基础设施
  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
  
  mysql:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=rootpass
      - MYSQL_DATABASE=payment
    volumes:
      - mysql_data:/var/lib/mysql
  
  kafka:
    image: confluentinc/cp-kafka:latest
    environment:
      - KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181
      - KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://kafka:9092
    depends_on:
      - zookeeper
  
  zookeeper:
    image: confluentinc/cp-zookeeper:latest
    environment:
      - ZOOKEEPER_CLIENT_PORT=2181

volumes:
  redis_data:
  mysql_data:
```

### 5.2 Kubernetes部署

```yaml
# k8s-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: payment-gateway
  namespace: payment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: payment-gateway
  template:
    metadata:
      labels:
        app: payment-gateway
    spec:
      containers:
      - name: payment-gateway
        image: payment-gateway:v1.0.0
        ports:
        - containerPort: 8080
        env:
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: payment-secrets
              key: redis-url
        - name: DB_URL
          valueFrom:
            secretKeyRef:
              name: payment-secrets
              key: db-url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: payment-gateway-service
  namespace: payment
spec:
  selector:
    app: payment-gateway
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: LoadBalancer
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: payment-gateway-hpa
  namespace: payment
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: payment-gateway
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

## 六、总结与最佳实践

### 6.1 架构设计原则

1. **高可用性**：多活部署、故障隔离、自动恢复
2. **高性能**：缓存优化、异步处理、负载均衡
3. **安全性**：数据加密、访问控制、风险防控
4. **可扩展性**：微服务架构、水平扩展、弹性伸缩
5. **可观测性**：全链路监控、结构化日志、性能指标

### 6.2 关键技术选型

**编程语言**：Go（高并发）、Java（生态丰富）
**数据库**：MySQL（事务性）、Redis（缓存）
**消息队列**：Kafka（高吞吐）、RabbitMQ（可靠性）
**容器化**：Docker + Kubernetes
**监控**：Prometheus + Grafana

### 6.3 运维最佳实践

1. **自动化部署**：CI/CD流水线、蓝绿部署
2. **容量规划**：压力测试、性能基线、扩容预案
3. **故障处理**：监控告警、应急响应、故障复盘
4. **安全管控**：权限管理、审计日志、合规检查
5. **持续优化**：性能调优、架构演进、技术升级

---

> 聚合支付系统作为金融科技的重要基础设施，需要在业务创新与风险控制之间找到平衡。本指南提供了从架构设计到运维监控的完整解决方案，旨在帮助构建安全、稳定、高效的聚合支付平台。在实际应用中，应根据具体业务场景和监管要求，选择合适的技术方案和实施策略。