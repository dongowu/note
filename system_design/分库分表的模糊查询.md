# 分库分表场景下模糊查询详细设计方案

## 1. 核心问题分析

### 1.1 挑战点
- **分片键限制**：用户表按user_id分片，但查询条件是phone、name
- **数据分散**：用户数据分布在16个库×32张表=512个物理表中
- **查询复杂度**：模糊查询无法利用索引优势
- **性能要求**：需要毫秒级响应，支持高并发

### 1.2 查询场景分析
- **精确查询**：phone = '13800138000'（可以建立映射表）
- **前缀查询**：phone LIKE '138%'（相对容易优化）
- **包含查询**：phone LIKE '%8888%'（最困难）
- **多字段组合**：phone + name 组合查询
- **复杂条件**：支持状态、时间范围等过滤

## 2. 方案对比分析

### 2.1 方案对比矩阵

| 方案名称 | 查询性能 | 存储成本 | 开发复杂度 | 维护成本 | 数据一致性 | 扩展性 |
|---------|---------|---------|-----------|---------|-----------|--------|
| 搜索引擎方案 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 数据冗余方案 | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| 全库扫描方案 | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐ |
| 映射表方案 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |

### 2.2 适用场景分析

#### 搜索引擎方案
- **适用场景**：查询频率高、对性能要求高、业务发展快速
- **不适用**：对数据一致性要求极高、预算有限

#### 数据冗余方案
- **适用场景**：数据量中等、查询相对简单、团队技术栈偏传统
- **不适用**：数据量特别大、存储成本敏感

#### 全库扫描方案
- **适用场景**：管理后台、查询频率低、开发资源有限
- **不适用**：用户端查询、高并发场景

## 3. 方案一：搜索引擎方案（推荐）

### 3.1 整体架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                    应用层 (API Gateway)                      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                  查询路由层 (Query Router)                   │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐      │
│  │  精确查询    │    │  模糊查询    │    │  复合查询    │      │
│  │   Router    │    │   Router    │    │   Router    │      │
│  └─────────────┘    └─────────────┘    └─────────────┘      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                      缓存层 (Multi-Cache)                    │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐      │
│  │ Redis Cache │    │Local Cache  │    │ Query Cache │      │
│  └─────────────┘    └─────────────┘    └─────────────┘      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   搜索引擎层 (Elasticsearch)                  │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐      │
│  │   索引分片   │    │   索引分片   │    │   索引分片   │      │
│  │   Shard 1   │    │   Shard 2   │    │   Shard N   │      │
│  └─────────────┘    └─────────────┘    └─────────────┘      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                 数据存储层 (Database Cluster)                │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐      │
│  │    DB 1     │    │    DB 2     │    │    DB N     │      │
│  └─────────────┘    └─────────────┘    └─────────────┘      │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 Elasticsearch设计

#### 索引结构设计
```json
{
  "index_name": "user_search_v1",
  "settings": {
    "number_of_shards": 6,
    "number_of_replicas": 1,
    "refresh_interval": "5s",
    "analysis": {
      "analyzer": {
        "phone_analyzer": {
          "type": "custom",
          "tokenizer": "keyword",
          "filter": ["lowercase", "phone_ngram"]
        },
        "name_analyzer": {
          "type": "custom",
          "tokenizer": "ik_max_word",
          "filter": ["lowercase", "pinyin_full", "pinyin_first_letter"]
        }
      },
      "filter": {
        "phone_ngram": {
          "type": "ngram",
          "min_gram": 3,
          "max_gram": 11
        },
        "pinyin_full": {
          "type": "pinyin",
          "keep_full_pinyin": true,
          "keep_joined_full_pinyin": true
        },
        "pinyin_first_letter": {
          "type": "pinyin",
          "keep_first_letter": true,
          "keep_full_pinyin": false
        }
      }
    }
  }
}
```

#### 文档映射设计
```json
{
  "mappings": {
    "properties": {
      "user_id": {"type": "long"},
      "phone": {
        "type": "text",
        "analyzer": "phone_analyzer",
        "fields": {
          "keyword": {"type": "keyword"},
          "prefix": {
            "type": "text",
            "analyzer": "standard",
            "search_analyzer": "standard"
          }
        }
      },
      "name": {
        "type": "text",
        "analyzer": "name_analyzer",
        "fields": {
          "keyword": {"type": "keyword"},
          "pinyin": {
            "type": "text",
            "analyzer": "pinyin_analyzer"
          },
          "standard": {
            "type": "text",
            "analyzer": "standard"
          }
        }
      },
      "email": {"type": "keyword"},
      "status": {"type": "integer"},
      "create_time": {"type": "date"},
      "update_time": {"type": "date"},
      "db_shard": {"type": "keyword"},
      "table_shard": {"type": "keyword"}
    }
  }
}
```

### 3.3 查询策略设计

#### 手机号查询策略
- **精确查询**：使用keyword字段
- **前缀查询**：使用prefix字段 + prefix query
- **包含查询**：使用ngram分词 + match query
- **模糊查询**：使用wildcard query（性能较差，需限制）

#### 姓名查询策略
- **中文查询**：使用ik分词器
- **拼音查询**：支持全拼、简拼查询
- **模糊匹配**：结合编辑距离（fuzziness）
- **同音字查询**：利用拼音分析器

#### 查询优先级策略
1. **精确匹配**：权重最高，直接返回
2. **前缀匹配**：权重次高，常用场景
3. **包含匹配**：权重中等，使用ngram
4. **模糊匹配**：权重最低，限制使用

### 3.4 数据同步设计

#### 同步架构
```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   用户服务   │───▶│   消息队列   │───▶│  同步服务    │
│             │    │   (Kafka)   │    │             │
└─────────────┘    └─────────────┘    └─────────────┘
                                              │
                                              ▼
                                    ┌─────────────┐
                                    │     ES      │
                                    │   集群      │
                                    └─────────────┘
```

#### 同步策略
- **实时同步**：用户数据变更后立即同步到ES
- **增量同步**：定时任务处理失败的同步数据
- **全量同步**：每日凌晨进行数据一致性校验
- **重试机制**：失败数据进入重试队列，指数退避

#### 一致性保障
- **最终一致性**：ES数据允许短暂延迟
- **版本控制**：使用update_time作为版本号
- **冲突处理**：后写入的数据覆盖先写入的数据
- **数据校验**：定期校验ES与DB数据一致性

### 3.5 性能优化设计

#### 查询优化
- **查询缓存**：热点查询结果缓存5分钟
- **索引预热**：启动时预热常用查询
- **分页优化**：深分页使用scroll API
- **查询重写**：将复杂查询拆分为多个简单查询

#### 写入优化
- **批量写入**：批量同步数据到ES，减少网络开销
- **异步写入**：通过消息队列异步写入，提高响应速度
- **索引优化**：合理设置refresh_interval和段合并策略
- **分片策略**：根据数据量合理分片，避免分片过大或过小

## 4. 方案二：数据冗余方案

### 4.1 架构设计

#### 冗余表设计
```sql
-- 用户搜索表
CREATE TABLE user_search_00 (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    phone VARCHAR(20),
    name VARCHAR(100),
    email VARCHAR(100),
    status TINYINT,
    create_time DATETIME,
    update_time DATETIME,

    -- 索引设计
    UNIQUE KEY uk_user_id (user_id),
    KEY idx_phone (phone),
    KEY idx_name (name),
    KEY idx_phone_name (phone, name),
    KEY idx_status_time (status, create_time)
) ENGINE=InnoDB;

-- 按照模10的方式分10张表
-- user_search_00 到 user_search_09
```

#### 分表策略
- **分表依据**：按user_id % 10分表
- **表数量**：10张表（可根据数据量调整）
- **查询策略**：查询时需要扫描所有分表
- **索引策略**：每张表都有完整的索引

### 4.2 查询路由设计

#### 路由策略
```
查询请求 ──┐
          ├─▶ user_search_00
          ├─▶ user_search_01
          ├─▶ user_search_02
          ├─▶     ...
          └─▶ user_search_09
             │
             ▼
         结果聚合 ──▶ 排序分页 ──▶ 返回结果
```

#### 聚合策略
- **并行查询**：同时查询所有分表
- **结果合并**：内存中合并查询结果
- **排序分页**：统一排序后分页返回
- **性能优化**：使用连接池，控制并发数

### 4.3 数据同步设计

#### 同步时机
- **新增用户**：立即插入搜索表
- **更新用户**：立即更新搜索表对应记录
- **删除用户**：立即删除搜索表对应记录
- **批量修复**：定时任务检查数据一致性

#### 事务保障
- **分布式事务**：使用Seata等保证用户表和搜索表数据一致
- **补偿机制**：失败时的数据回滚和补偿
- **重试机制**：失败操作的重试策略
- **监控告警**：数据不一致时的告警机制

### 4.4 优劣势分析

#### 优势
- **查询性能好**：直接利用MySQL索引
- **技术栈简单**：无需引入新的中间件
- **数据一致性高**：可以使用事务保证强一致性
- **运维成本低**：MySQL运维成熟

#### 劣势
- **存储成本高**：需要额外的存储空间
- **同步复杂度**：需要维护多张表的数据一致性
- **扩展性有限**：分表数量有限制
- **功能受限**：复杂查询功能不如ES强大

## 5. 方案三：全库扫描方案（管理后台）

### 5.1 设计思路

适用于管理后台等低频查询场景，通过优化减少全库扫描的性能影响。

#### 扫描策略
- **并行扫描**：同时扫描多个分片
- **提前终止**：找到足够结果后提前结束
- **缓存结果**：相同查询条件缓存结果
- **异步处理**：超时查询转为异步，后台处理

### 5.2 优化手段

#### 查询优化
- **索引优化**：在每个分片上建立查询需要的索引
- **分页限制**：限制单次查询的最大返回数量
- **超时控制**：设置查询超时时间，避免长时间占用资源
- **降级策略**：查询超时时返回部分结果

#### 缓存策略
- **查询缓存**：相同条件的查询结果缓存30分钟
- **计数缓存**：总数统计结果缓存，减少count查询
- **热点缓存**：常用查询条件提前缓存
- **预加载**：后台预先执行常用查询

## 6. 方案四：映射表方案

### 6.1 设计思路

为常用的查询字段建立反向映射表，支持精确查询和前缀查询。

#### 映射表设计
```sql
-- 手机号映射表
CREATE TABLE phone_user_mapping (
    phone VARCHAR(20) PRIMARY KEY,
    user_id BIGINT NOT NULL,
    db_shard VARCHAR(20),
    table_shard VARCHAR(20),
    create_time DATETIME,

    INDEX idx_user_id (user_id)
) ENGINE=InnoDB;

-- 姓名映射表（支持前缀）
CREATE TABLE name_user_mapping (
    name_prefix VARCHAR(50),
    user_id BIGINT,
    full_name VARCHAR(100),
    db_shard VARCHAR(20),
    table_shard VARCHAR(20),
    create_time DATETIME,

    PRIMARY KEY (name_prefix, user_id),
    INDEX idx_user_id (user_id)
) ENGINE=InnoDB;
```

### 6.2 查询策略

#### 精确查询
1. 根据phone在映射表中查找user_id
2. 根据user_id直接定位到具体分片
3. 查询完整用户信息

#### 前缀查询
1. 在姓名映射表中查找匹配的前缀
2. 获取所有匹配的user_id列表
3. 批量查询用户详细信息

#### 模糊查询
- **手机号包含**：需要扫描映射表，性能较差
- **姓名包含**：建立多个前缀映射，支持有限的模糊查询

## 7. 混合方案设计

### 7.1 智能路由策略

根据查询条件的特征，自动选择最优的查询方案：

#### 路由规则
```
查询条件分析 ──┐
             ├─ 精确查询 ──▶ 映射表方案
             ├─ 前缀查询 ──▶ ES方案（优先）/ 映射表方案
             ├─ 模糊查询 ──▶ ES方案
             ├─ 复合查询 ──▶ ES方案
             └─ 管理查询 ──▶ 全库扫描 / 数据冗余方案
```

#### 降级策略
- **ES异常时**：降级到数据冗余方案或全库扫描
- **高并发时**：优先使用缓存结果
- **超时情况**：返回部分结果或提示稍后查询
- **资源不足**：限制查询频率，启用排队机制

### 7.2 性能目标

#### 响应时间目标
- **精确查询**：< 50ms
- **前缀查询**：< 100ms
- **模糊查询**：< 200ms
- **复合查询**：< 300ms

#### 并发目标
- **查询QPS**：> 1000
- **写入QPS**：> 500
- **缓存命中率**：> 90%
- **可用性**：> 99.9%

## 8. 总结与建议

### 8.1 方案推荐

#### 生产环境推荐
1. **主力方案**：Elasticsearch搜索引擎方案
2. **辅助方案**：映射表方案（精确查询）
3. **降级方案**：数据冗余方案
4. **管理后台**：全库扫描方案

#### 分阶段实施
1. **第一阶段**：实施映射表方案，解决精确查询问题
2. **第二阶段**：引入ES，支持复杂模糊查询
3. **第三阶段**：完善缓存和监控，优化性能
4. **第四阶段**：实现智能路由和降级策略

### 8.2 关键成功因素

#### 技术因素
- **数据同步的可靠性**：确保查询数据与业务数据一致
- **查询性能的稳定性**：避免查询性能波动过大
- **系统的可扩展性**：支持数据量和查询量的持续增长
- **故障的容错能力**：部分组件故障时系统仍可用

#### 运维因素
- **监控体系完善**：及时发现性能问题和数据不一致
- **自动化程度高**：减少人工运维成本
- **文档和培训**：团队成员都能熟练运维系统
- **应急预案完备**：故障时能快速恢复服务
